<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body><a href="https://github.com/bojand/couchbase-driver"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Driver.html">Driver</a><ul class='methods'><li data-type='method'><a href="Driver.html#.isKeyNotFound">isKeyNotFound</a></li><li data-type='method'><a href="Driver.html#atomic">atomic</a></li><li data-type='method'><a href="Driver.html#get">get</a></li><li data-type='method'><a href="Driver.html#remove">remove</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#create">create</a></li><li><a href="global.html#OPERATIONS">OPERATIONS</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import _ from 'lodash';
import async from 'async';
import bluebird from 'bluebird';
import { errors } from 'couchbase';

const debug = require('debug')('couchbase-driver');

/**
 * Enum for Database operations
 * @readonly
 * @enum {string}
 */
const OPERATIONS = {
  /** Upsert operation */
  UPSERT: 'upsert',
  /** Remove operation */
  REMOVE: 'remove',
  /** No operation or action */
  NOOP: 'noop'
};

const defaultOptions = {
  atomicRetryTimes: 5,
  atomicRetryInterval: 0,
  missing: true
};

export class Driver {

  /**
   * @classdesc A simple alternative driver for Couchbase that wraps the `Bucket` from existing driver and improves
   * &lt;code>get&lt;/code> and &lt;code>remove&lt;/code> methods and adds &lt;code>atomic&lt;/code> method.
   *
   * @description
   * Constructs the new instance. This should not be called directly, but rather use &lt;code>create()&lt;/code>.
   *
   * @param {Object} bucket the Couchbase &lt;code>Bucket&lt;/code>
   * @param options {Object} Options
   * @param {Number} options.atomicRetryTimes - The number of attempts to make within &lt;code>atomic()&lt;/code>.
   *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>5&lt;/code>.
   * @param {Number} options.atomicRetryInterval - The time to wait between retries, in milliseconds, within &lt;code>atomic()&lt;/code>.
   *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>0&lt;/code>.
   * @param {Boolean} options.missing - Whether to return missing. If &lt;code>false&lt;/code> Does not return.
   *                                    Useful for certain contexts.
   */
  constructor(bucket, options) {
    this.bucket = bucket;
    this.config = _.defaults(options || {}, defaultOptions);
  }

  /**
   * Get operation enums
   * @example
   * driver.OPERATIONS.UPSERT;
   */
  get OPERATIONS() {
    return OPERATIONS;
  }

  /**
   * Get operation enums
   * @example
   * const Driver = require('couchbase-driver').Driver;
   * console.log(Driver.OPERATIONS.UPSERT);
   */
  static get OPERATIONS() {
    return OPERATIONS;
  }

  /**
   * Determines if error is a "key not found" error
   * @param {Error} err - the error to check
   * @example
   * Driver.isKeyNotFound(err);
   */
  static isKeyNotFound(err) {
    let keyNotFound = false;
    if (err &amp;&amp; _.isObject(err)) {
      if (err.code &amp;&amp; err.code === errors.keyNotFound) {
        keyNotFound = true;
      } else if (err.message &amp;&amp; err.message === 'key not found') {
        keyNotFound = true;
      } else if (err.message &amp;&amp; err.message.indexOf('key does not exist') >= 0) {
        keyNotFound = true;
      } else if (err.message &amp;&amp; err.message.indexOf('key not found') >= 0) {
        keyNotFound = true;
      } else if (err.code &amp;&amp; err.code.toString() === '13') {
        keyNotFound = true;
      }
    }

    return keyNotFound;
  }

  /**
   * A simplified get. Properly handles key not found errors. In case of multi call, returns array of found
   * and an array of misses.
   * @param {String|Array} keys - a single key or multiple keys
   * @param {Object} options - Options for bucket &lt;code>get&lt;/code> function
   * @param {Boolean} options.missing - Whether to return missing. If &lt;code>false&lt;/code> Does not return.
   *                                    Useful for certain contexts. This option takes presidence over the one set in
   *                                    constructor.
   * @param {Function} fn callback
   * @example
   * driver.get('my_doc_key', (err, res) => {
   *   if (err) return console.log(err)
   *   console.dir(res.value)
   * }
   * @example
   * driver.get(['my_doc_key_1', 'my_doc_key_2', 'my_missing_doc_key_3'], (err, results, missing) => {
   *   if (err) return console.log(err);
   *   if (mising.length > 0) console.dir(missing); // ['my_missing_doc_key_3']
   *   console.dir(res.value);
   * });
   */
  get(keys, options, fn) {
    if (options instanceof Function) {
      fn = options;
      options = {};
    }

    if (!fn) {
      fn = _.noop;
    }

    if (!keys || (Array.isArray(keys) &amp;&amp; !keys.length)) {
      return process.nextTick(() => {
        return fn();
      });
    }

    if (Array.isArray(keys)) {
      debug(`driver.getMulti. keys: ${keys}`);
      this.bucket.getMulti(keys, (err, getRes) => {
        if (err &amp;&amp; _.isObject(err)) {
          return fn(err);
        }

        const misses = [];
        const results = [];
        let errors = [];

        keys.forEach(k => {
          if (getRes.hasOwnProperty(k) &amp;&amp; getRes[k]) {
            if (getRes[k].value) {
              results.push({
                value: getRes[k].value,
                cas: getRes[k].cas
              });
            } else if (getRes[k].error &amp;&amp; Driver.isKeyNotFound(getRes[k].error)) {
              misses.push(k);
            } else if (getRes[k].error) {
              errors.push([getRes[k].error]);
            }
          }
        });

        if (errors.length === 0) {
          errors = null;
        }

        if (this.config.missing === false) {
          if (options.missing === true) {
            return fn(err, results, misses);
          }

          return fn(err, results);
        }

        if (options.missing === false) {
          return fn(err, results);
        }

        return fn(errors, results, misses);
      });
    } else {
      debug(`driver.get. keys: ${keys}`);
      this.bucket.get(keys, options, (err, getRes) => {
        if (err &amp;&amp; Driver.isKeyNotFound(err)) {
          err = null;
        }

        return fn(err, getRes);
      });
    }
  }

  /**
   * Our implementation of &lt;code>Bucket.remove&lt;/code> that properly ignores key not found errors.
   * @param {String} key - document key to remove
   * @param {Object} options - Options to pass to &lt;code>Bucket.remove&lt;/code>
   * @param {Function} fn - callback
   * @example
   * driver.remove('my_doc_key', (err, res) => {
   *   if (err) return console.log(err);
   * });
   */
  remove(key, options, fn) {
    if (options instanceof Function) {
      fn = options;
      options = {};
    }

    if (!fn) {
      fn = _.noop;
    }

    if (!key) {
      return process.nextTick(() => {
        return fn();
      });
    }

    debug(`Driver.remove. key: ${key}`);
    this.bucket.remove(key, options, (err, rres) => {
      if (err &amp;&amp; Driver.isKeyNotFound(err)) {
        err = null;
      }

      return fn(err, rres);
    });
  }

  /**
   * Performs an "atomic" operation where it tries to first get the document given the &lt;code>key&lt;/code>, then perform
   * the function &lt;code>transform&lt;/code> on the value and then write using the CAS value in the &lt;code>upsert&lt;/code>.
   * If the upsert fails due to a CAS value error, the whole process is retried.
   * @param {String} key - document key
   * @param {Function} transform - synchronous function to be performend on the document value. Function accepts the
   *                               document or &lt;code>undefined&lt;/code> if the document was not found. The function
   *                               should perform any necessary mutation and return an object with &lt;code>value&lt;/code>
   *                               and &lt;code>action&lt;/code>. &lt;code>value&lt;/code> is the new value of the document.
   *                               &lt;code>action&lt;/code> should be one of &lt;code>OPERATIONS&lt;/code> specifying the action
   *                               to take with the new value.
   * @param {String} options - Options
   * @param {Number} options.atomicRetryTimes - The number of attempts to make within &lt;code>atomic()&lt;/code>.
   *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>5&lt;/code>.
   * @param {Number} options.atomicRetryInterval - The time to wait between retries, in milliseconds, within &lt;code>atomic()&lt;/code>.
   *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>0&lt;/code>.
   * @param {Function} fn - callback
   * @example
   * function transform(doc) {
   *   doc.foo = 'bar';
   *   return {
   *     value: doc,
   *     action: OPERATIONS.UPSERT
   *   };
   * }
   *
   * driver.atomic('my_doc_key', transform, (err, res) => {
   *   if(err) return console.dir(err);
   *   console.dir(res);
   * });
   */
  atomic(key, transform, options, fn) {
    if (options instanceof Function) {
      fn = options;
      options = {};
    }

    const retryOptions = _.defaults(options || {}, this.config);

    async.retry(retryOptions, rfn => {
      this.get(key, (err, doc) => {
        if (err) {
          return rfn(err);
        }

        const opr = transform(doc ? doc.value : undefined);
        const opts = doc ? { cas: doc.cas } : {};
        if (opr.action === OPERATIONS.NOOP) {
          return rfn(null, opr.value);
        } else if (opr.action === OPERATIONS.UPSERT &amp;&amp; opr.value) {
          return this.bucket.upsert(key, opr.value, opts, rfn);
        }
        return this.bucket.remove(key, opts, rfn);
      });
    }, fn);
  }
}

/**
 * Create a Driver object by wrapping the Couchbase bucket and creates a new &lt;code>Driver&lt;/code> instance and
 * adds &lt;code>Promise&lt;/code> support to the instance.
 * @param bucket {Object} The Couchbase &lt;code>Bucket&lt;/code> instance to wrap.
 * @param options {Object} Options
 * @param {Number} options.atomicRetryTimes - The number of attempts to make within &lt;code>atomic()&lt;/code>.
 *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>5&lt;/code>.
 * @param {Number} options.atomicRetryInterval - The time to wait between retries, in milliseconds, within &lt;code>atomic()&lt;/code>.
 *                                             	 See &lt;code>async.retry&lt;/code>. Default: &lt;code>0&lt;/code>.
 * @returns {Driver}
 * @example
 * const couchbase = require('couchbase');
 * const create = require('couchbase-driver').create;
 * const cluster = new couchbase.Cluster('couchbase://127.0.0.1');
 * const bucket = cluster.openBucket('default');
 * const driver = create(bucket);
 */
export function create(bucket, options) {
  // wrap the class
  const bucketPrototype = Object.getPrototypeOf(bucket);
  let fnNames = [];
  let p;
  for (p in bucketPrototype) {
    if (bucketPrototype.hasOwnProperty(p) &amp;&amp; p.charAt(0) !== '_' &amp;&amp;
      typeof bucketPrototype[p] === 'function' &amp;&amp; !Driver.prototype[p]) {
      fnNames.push(p);
    }
  }

  fnNames.forEach(fnName => {
    Driver.prototype[fnName] = function () {
      this.bucket[fnName](...arguments);
    };
  });

  // craete the instance
  const d = new Driver(bucket, options);

  // Promisify the instance to allow both callback and Promise based invokation
  const names = Object.getOwnPropertyNames(Object.getPrototypeOf(d));
  fnNames = _.filter(names, name => {
    return typeof Driver.prototype[name] === 'function' &amp;&amp; name !== 'constructor';
  });

  fnNames.forEach(name => {
    const originalFn = d[name];
    d[name] = function () {
      const lastArg = arguments[arguments.length - 1];
      return bluebird.promisify(originalFn, { context: d })(...arguments).asCallback(lastArg, { spread: true });
    };
  });

  return d;
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Jul 27 2016 10:22:36 GMT-0300 (ADT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
